// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: batch.go

package repository

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createManyLayouts = `-- name: CreateManyLayouts :batchexec
insert into layouts (id, tournament_id, name, course_name, length, units, holes, par)
values ($1, $2, $3, $4, $5, $6, $7, $8)
returning id, tournament_id, name, course_name, length, units, holes, par
`

type CreateManyLayoutsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateManyLayoutsParams struct {
	ID           int64
	TournamentID int64
	Name         string
	CourseName   string
	Length       pgtype.Int4
	Units        pgtype.Text
	Holes        pgtype.Int4
	Par          pgtype.Int4
}

func (q *Queries) CreateManyLayouts(ctx context.Context, arg []CreateManyLayoutsParams) *CreateManyLayoutsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.TournamentID,
			a.Name,
			a.CourseName,
			a.Length,
			a.Units,
			a.Holes,
			a.Par,
		}
		batch.Queue(createManyLayouts, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateManyLayoutsBatchResults{br, len(arg), false}
}

func (b *CreateManyLayoutsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateManyLayoutsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createManyPlayers = `-- name: CreateManyPlayers :batchexec
insert into players (pdga_number, first_name, last_name, name, division, city, state_prov, country)
values ($1, $2, $3, $4, $5, $6, $7, $8)
on conflict (pdga_number) do nothing
`

type CreateManyPlayersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateManyPlayersParams struct {
	PdgaNumber int64
	FirstName  string
	LastName   string
	Name       string
	Division   string
	City       pgtype.Text
	StateProv  pgtype.Text
	Country    pgtype.Text
}

func (q *Queries) CreateManyPlayers(ctx context.Context, arg []CreateManyPlayersParams) *CreateManyPlayersBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.PdgaNumber,
			a.FirstName,
			a.LastName,
			a.Name,
			a.Division,
			a.City,
			a.StateProv,
			a.Country,
		}
		batch.Queue(createManyPlayers, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateManyPlayersBatchResults{br, len(arg), false}
}

func (b *CreateManyPlayersBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateManyPlayersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createRoundScores = `-- name: CreateRoundScores :batchexec
insert into scores (player_id, tournament_id, layout_id, round_number, score)
values ($1, $2, $3, $4, $5)
`

type CreateRoundScoresBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateRoundScoresParams struct {
	PlayerID     int64
	TournamentID int64
	LayoutID     int64
	RoundNumber  int32
	Score        int32
}

func (q *Queries) CreateRoundScores(ctx context.Context, arg []CreateRoundScoresParams) *CreateRoundScoresBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.PlayerID,
			a.TournamentID,
			a.LayoutID,
			a.RoundNumber,
			a.Score,
		}
		batch.Queue(createRoundScores, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateRoundScoresBatchResults{br, len(arg), false}
}

func (b *CreateRoundScoresBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateRoundScoresBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
